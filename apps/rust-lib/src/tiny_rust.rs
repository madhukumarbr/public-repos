#[allow(dead_code)]
#[allow(unused_variables)]
extern crate libc;
use libc::{c_char, c_void, c_int};
use std::mem;
use std::ptr;

extern {
    fn double_input(input: libc::c_int) -> libc::c_int;
}

#[no_mangle]
pub static rust_value:i32 =22;

#[no_mangle]
pub static array : [i32;2]= [77,88];

#[no_mangle]
pub static mut global_array : [i32;2] = [123, 456];
////////////////////////////////////////////////////////////////////////////////////////
type clock_time_t = i32;
type dtls_tick_t = clock_time_t;
type lc_t = u8;
type size_t = u16;

#[no_mangle]
pub struct timer {
	start: clock_time_t,
	interval: clock_time_t
}

#[no_mangle]
pub struct pt {
    lc: lc_t,
}

#[no_mangle]
pub struct process {
	next: *mut process,
	name: &'static str,
	thread: unsafe extern fn(process_pt: *const pt, ev: c_char, data: * mut c_void) -> c_char,
	pt : pt,
	state:c_char,
	needspoll: c_char,
}

#[no_mangle]
pub struct etimer {
	timer: timer,
	next: *mut etimer,
	p: *mut process
}

#[no_mangle]
enum dtls_alert_level_t {
  DTLS_ALERT_LEVEL_WARNING=1,
  DTLS_ALERT_LEVEL_FATAL=2
}

#[no_mangle]
enum dtls_credentials_type_t {
  DTLS_PSK_HINT, DTLS_PSK_IDENTITY, DTLS_PSK_KEY
}


#[no_mangle]
pub struct uip_ip6addr_t {
	u18 : [u8;16],
	u16 : [u16;8]
}

type uip_ipaddr_t = uip_ip6addr_t;


#[no_mangle]
pub struct session_t{
  size:c_char,
  addr: uip_ipaddr_t,
  port: u8,
  ifindex: i32
}

/**
 * This structure contains callback functions used by tinydtls to
 * communicate with the application. At least the write function must
 * be provided. It is called by the DTLS state machine to send packets
 * over the network. The read function is invoked to deliver decrypted
 * and verfified application data. The third callback is an event
 * handler function that is called when alert messages are encountered
 * or events generated by the library have occured.
 */ 

#[no_mangle]
pub struct dtls_handler_t{
  /** 
   * Called from dtls_handle_message() to send DTLS packets over the
   * network. The callback function must use the network interface
   * denoted by session->ifindex to send the data.
   *
   * @param ctx  The current DTLS context.
   * @param session The session object, including the address of the
   *              remote peer where the data shall be sent.
   * @param buf  The data to send.
   * @param len  The actual length of @p buf.
   * @return The callback function must return the number of bytes 
   *         that were sent, or a value less than zero to indicate an 
   *         error.
   */
	write: unsafe extern fn(ctx: *mut dtls_context_t, session: *mut session_t, buf: * mut u8, len: size_t) -> c_int,

  /** 
   * Called from dtls_handle_message() deliver application data that was 
   * received on the given session. The data is delivered only after
   * decryption and verification have succeeded. 
   *
   * @param ctx  The current DTLS context.
   * @param session The session object, including the address of the
   *              data's origin. 
   * @param buf  The received data packet.
   * @param len  The actual length of @p buf.
   * @return ignored
   */
	read: unsafe extern fn(ctx: *mut dtls_context_t, session: *mut session_t, buf: * mut u8, len: size_t) -> c_int,

  /**
   * The event handler is called when a message from the alert
   * protocol is received or the state of the DTLS session changes.
   *
   * @param ctx     The current dtls context.
   * @param session The session object that was affected.
   * @param level   The alert level or @c 0 when an event ocurred that 
   *                is not an alert. 
   * @param code    Values less than @c 256 indicate alerts, while
   *                @c 256 or greater indicate internal DTLS session changes.
   * @return ignored
   */
	event: unsafe extern fn(ctx: *mut dtls_context_t, session: *mut session_t, level: dtls_alert_level_t, code: u8) -> c_int,

  /**
   * Called during handshake to get information related to the
   * psk key exchange. The type of information requested is
   * indicated by @p type which will be one of DTLS_PSK_HINT,
   * DTLS_PSK_IDENTITY, or DTLS_PSK_KEY. The called function
   * must store the requested item in the buffer @p result of
   * size @p result_length. On success, the function must return
   * the actual number of bytes written to @p result, of a
   * value less than zero on error. The parameter @p desc may
   * contain additional request information (e.g. the psk_identity
   * for which a key is requested when @p type == @c DTLS_PSK_KEY.
   *
   * @param ctx     The current dtls context.
   * @param session The session where the key will be used.
   * @param type    The type of the requested information.
   * @param desc    Additional request information
   * @param desc_len The actual length of desc.
   * @param result  Must be filled with the requested information.
   * @param result_length  Maximum size of @p result.
   * @return The number of bytes written to @p result or a value
   *         less than zero on error.
   */
	get_psk_info: unsafe extern fn(ctx: *mut dtls_context_t, session: *mut session_t, dtls_type: dtls_credentials_type_t, 
								desc: &'static str, desc_len: size_t, result: &'static str, result_length:size_t) -> c_int,
}


/** Holds global information of the DTLS engine. */
#[no_mangle]
pub struct dtls_context_t {
	cookie_secret:[c_char;12],
	cookie_secret_age:clock_time_t, /**< the time the secret has been generated */
	peers_list: *mut c_void,
    peers:*mut *mut c_void,
	retransmit_timer: etimer, /**< fires when the next packet must be sent */
	sendqueue_list: *mut c_void,
    sendqueue:*mut*mut c_void,
	app: *mut c_void,			/**< application-specific data */
	h: *mut dtls_handler_t,		/**< callback handlers */
	readbuf: [c_char;100]
}

///////////////////////////////////////////////////////////////////////////////////////////
pub static num : u8= 13;

fn malloc_context() -> *const u8 {
	let num_ptr: *const u8=&num;
	num_ptr
}

#[no_mangle]
pub unsafe extern "C" fn dtls_new_context(app_data: * mut c_void) -> *const u8//*mut dtls_context_t 
{
	let c:*mut dtls_context_t;
	let now:dtls_tick_t=46546;
	malloc_context()

}

#[no_mangle]
pub unsafe extern "C" fn rust_function(para1: i32, ev: i32, data: * mut c_void) -> i32 
{
	println!("Hello, from Rust");
	println!("Value of array in rust {}",array[0]);
	println!("Value of global variable in rust {}",rust_value);
	global_array[1]=double_input(ev);
	global_array[1]
}

/*
#[allow(dead_code)]
#[allow(unused_variables)]
extern crate libc;
use libc::{c_char, c_void};

#[allow(dead_code)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pt {
    lc: i8,
}

#[allow(dead_code)]
#[allow(unused_variables)]
const MYPT: pt = pt{lc:8};

#[allow(dead_code)]
#[no_mangle]
#[repr(C)]
pub struct process {
	next: Option<&'static process>,
	name: &'static str,
	thread: unsafe extern fn(process_pt: *const pt, ev: c_char, data: * mut c_void) -> c_char,
	pt : pt,
	state:c_char,
	needspoll: c_char,
}

#[allow(dead_code)]
#[allow(unused_variables)]
pub static hello_world_process : process = process {
												next:None,
												name: "Hello world process",
												thread: process_thread_hello_world_process,
												pt: MYPT,
												state:1,
												needspoll:1,
};

#[no_mangle]
pub static rust_value:i32=123;

#[no_mangle]
pub static array : [i32;2]= [77,88];

#[no_mangle]
pub static global_array : [i32;10] = [123, 456,...];

#[allow(dead_code)]
#[allow(unused_variables)]
#[allow(unused_assignments)]
#[no_mangle]
pub unsafe extern "C" fn process_thread_hello_world_process(process_pt: *const pt, ev: c_char, data: * mut c_void) -> c_char 
{
		println!("Hello, from Rust");
	let mut pt_yield_flag: c_char = 1;
	
	pt_yield_flag = 0;
ev+1
}

*/
