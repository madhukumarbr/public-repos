#[allow(dead_code)]
#[allow(unused_variables)]
extern crate libc;
use libc::{c_char, c_void, c_int};
use std::mem;
use std::ptr;
pub mod dtls;

extern {
	fn rust_uip_htons(port:i32)->u8;
}

extern {
	fn rust_set_connection(dest:* const session_t)-> * mut uip_udp_conn;
}

extern {
	fn set_connection_address(addr:* const uip_ipaddr_t)-> c_void;
}

extern {
	fn rust_dtls_new_context(conn: * const uip_udp_conn)->*mut dtls_context_t;
}

extern {
	fn rust_serial_line_init();
}

extern {
	fn print_local_addresses();
}

extern 
{ 
static mut dtls_context: *mut dtls_context_t; 
} 

const garb_addresss: uip_ipaddr_t = uip_ipaddr_t{
													u16:[0;8]
	};

#[no_mangle]
pub static mut dst : session_t = session_t{
											size:88,
											addr: garb_addresss,
											port:0,
											ifindex:0
	};

//unsafe impl Sync for *const dtls_context_t { }

//#[no_mangle]
//pub static dtls_context : *const dtls_context_t = 0 as *const dtls_context_t;


#[no_mangle]
#[repr(C)]
pub struct uip_ip6addr_t {
	u16 : [u16;8]
}

type uip_ipaddr_t = uip_ip6addr_t;

#[no_mangle]
pub struct session_t{
  size:usize,
  addr: uip_ipaddr_t,
  port: u8,
  ifindex: i32
}

#[no_mangle]
pub struct tcpip_uipstate {
  p: *const process ,
  state: *mut c_void ,
}

type uip_udp_appstate_t = tcpip_uipstate;

#[no_mangle]
pub struct uip_udp_conn {
  ripaddr: uip_ipaddr_t ,
  lport: u16 ,
  rport: u16 ,
  ttl: u8 ,
  appstate: uip_udp_appstate_t
}

/*-----------------------------------implementation of init_dtls in rust-------------------------*/


			/*------------------------------data types------------------------------*/
pub type clock_time_t = i32;
pub type dtls_tick_t = clock_time_t;
pub type lc_t = u8;
pub type size_t = u16;

#[no_mangle]
pub struct timer {
	start: clock_time_t,
	interval: clock_time_t
}

#[no_mangle]
pub struct pt {
    lc: lc_t,
}

#[no_mangle]
pub struct process {
	next: *mut process,
	name: &'static str,
	thread: unsafe extern fn(process_pt: *const pt, ev: c_char, data: * mut c_void) -> c_char,
	pt : pt,
	state:c_char,
	needspoll: c_char,
}

#[no_mangle]
pub struct etimer {
	timer: timer,
	next: *mut etimer,
	p: *mut process
}

#[no_mangle]
enum dtls_alert_level_t {
  DTLS_ALERT_LEVEL_WARNING=1,
  DTLS_ALERT_LEVEL_FATAL=2
}

#[no_mangle]
enum dtls_credentials_type_t {
  DTLS_PSK_HINT, DTLS_PSK_IDENTITY, DTLS_PSK_KEY
}
			/*------------------------------data types------------------------------*/

			
			
/**
 * This structure contains callback functions used by tinydtls to
 * communicate with the application. At least the write function must
 * be provided. It is called by the DTLS state machine to send packets
 * over the network. The read function is invoked to deliver decrypted
 * and verfified application data. The third callback is an event
 * handler function that is called when alert messages are encountered
 * or events generated by the library have occured.
 */ 
#[no_mangle]
pub struct dtls_handler_t{
  /** 
   * Called from dtls_handle_message() to send DTLS packets over the
   * network. The callback function must use the network interface
   * denoted by session->ifindex to send the data.
   *
   * @param ctx  The current DTLS context.
   * @param session The session object, including the address of the
   *              remote peer where the data shall be sent.
   * @param buf  The data to send.
   * @param len  The actual length of @p buf.
   * @return The callback function must return the number of bytes 
   *         that were sent, or a value less than zero to indicate an 
   *         error.
   */
	write:  fn(ctx: *mut dtls_context_t, session: *mut session_t, buf: * mut u8, len: size_t) -> c_int,

  /** 
   * Called from dtls_handle_message() deliver application data that was 
   * received on the given session. The data is delivered only after
   * decryption and verification have succeeded. 
   *
   * @param ctx  The current DTLS context.
   * @param session The session object, including the address of the
   *              data's origin. 
   * @param buf  The received data packet.
   * @param len  The actual length of @p buf.
   * @return ignored
   */
	read:  fn(ctx: *mut dtls_context_t, session: *mut session_t, buf: * mut u8, len: size_t) -> c_int,

  /**
   * The event handler is called when a message from the alert
   * protocol is received or the state of the DTLS session changes.
   *
   * @param ctx     The current dtls context.
   * @param session The session object that was affected.
   * @param level   The alert level or @c 0 when an event ocurred that 
   *                is not an alert. 
   * @param code    Values less than @c 256 indicate alerts, while
   *                @c 256 or greater indicate internal DTLS session changes.
   * @return ignored
   */
	event:  fn(ctx: *mut dtls_context_t, session: *mut session_t, level: dtls_alert_level_t, code: u8) -> c_int,

  /**
   * Called during handshake to get information related to the
   * psk key exchange. The type of information requested is
   * indicated by @p type which will be one of DTLS_PSK_HINT,
   * DTLS_PSK_IDENTITY, or DTLS_PSK_KEY. The called function
   * must store the requested item in the buffer @p result of
   * size @p result_length. On success, the function must return
   * the actual number of bytes written to @p result, of a
   * value less than zero on error. The parameter @p desc may
   * contain additional request information (e.g. the psk_identity
   * for which a key is requested when @p type == @c DTLS_PSK_KEY.
   *
   * @param ctx     The current dtls context.
   * @param session The session where the key will be used.
   * @param type    The type of the requested information.
   * @param desc    Additional request information
   * @param desc_len The actual length of desc.
   * @param result  Must be filled with the requested information.
   * @param result_length  Maximum size of @p result.
   * @return The number of bytes written to @p result or a value
   *         less than zero on error.
   */
	get_psk_info: fn(ctx: *mut dtls_context_t, session: *mut session_t, dtls_type: dtls_credentials_type_t, 
								desc: &'static str, desc_len: size_t, result: &'static str, result_length:size_t) -> c_int,
}


#[no_mangle]
pub struct dtls_context_t {
	pub cookie_secret:[c_char;12],
	pub cookie_secret_age:clock_time_t, /**< the time the secret has been generated */
	pub peers_list: *const c_void,
    pub peers:*const *const c_void,
	pub retransmit_timer: etimer, /**< fires when the next packet must be sent */
	pub sendqueue_list: *const c_void,
    pub sendqueue:*const*const c_void,
	pub app: *const c_void,			/**< application-specific data */
	pub h: *const dtls_handler_t,		/**< callback handlers */
	pub readbuf: [c_char;2]
}


fn send_to_peer(ctx: *mut dtls_context_t, session: *mut session_t, buf: * mut u8, len: size_t) -> c_int {
0
}

fn read_from_peer(ctx: *mut dtls_context_t, session: *mut session_t, buf: * mut u8, len: size_t) -> c_int{
0
}

fn event_call(ctx: *mut dtls_context_t, session: *mut session_t, level: dtls_alert_level_t, code: u8) -> c_int{
0
}

fn get_psk_info(ctx: *mut dtls_context_t, session: *mut session_t, dtls_type: dtls_credentials_type_t, 
			desc: &'static str, desc_len: size_t, result: &'static str, result_length:size_t) -> c_int{
0
}



#[no_mangle]
pub unsafe extern "C" fn rust_init_dtls()->u8 
{
dtls::dtls_init();
static cb:dtls_handler_t = dtls_handler_t {
						write:send_to_peer,
						read: read_from_peer,
						event: event_call,
						get_psk_info: get_psk_info};
						

print_local_addresses();
dst.size = mem::size_of::<uip_ipaddr_t>()+mem::size_of::<u8>();
dst.port = rust_uip_htons(20220);
set_connection_address(&dst.addr);
let conn: *mut uip_udp_conn = rust_set_connection(&dst);

dtls_context = rust_dtls_new_context(conn);

if dtls_context==0 as *mut dtls_context_t
	{
		0
	}
else{
		(*dtls_context).h = &cb;
		rust_serial_line_init();
		1
	}
}

